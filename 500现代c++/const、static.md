# const
`const` 关键字用于声明常量，它指定了一个变量在初始化后不能被修改的特性。`const` 可以用于变量、成员函数和指针。

### 1. 常量变量（Const Variables）

常量变量一旦被初始化，就不能被修改。

```cpp
const int MAX_SIZE = 100; // 声明一个常量

int main() {
    // MAX_SIZE = 200; // 错误：常量不能被修改
    std::cout << "Max size: " << MAX_SIZE << std::endl;
    return 0;
}
```

### 2. 常量成员函数（Const Member Functions）

常量成员函数承诺不会修改对象的成员变量。在常量对象上调用常量成员函数是合法的，但在非常量对象上调用常量成员函数是不合法的。

```cpp
class MyClass {
public:
    int getValue() const { // 声明一个常量成员函数
        // some code
    }
};

int main() {
    const MyClass obj;
    int value = obj.getValue(); // 合法：在常量对象上调用常量成员函数
    return 0;
}
```

### 3. 指向常量的指针（Pointers to Constants）

指向常量的指针表示指针所指向的值是常量，**不能通过指针修改该值。

```cpp
int main() {
    const int* ptr; // 指向常量的指针
    int value = 5;
    ptr = &value;
    // *ptr = 10; // 错误：不能通过指针修改常量值
    return 0;
}
```

### 4. 常量指针（Constant Pointers）

常量指针表示指针本身是常量，**不能改变指针指向的地址。

```cpp
int main() {
    int value = 5;
    int* const ptr = &value; // 常量指针
    *ptr = 10; // 合法：可以通过常量指针修改指针指向的值
    // ptr = nullptr; // 错误：不能改变常量指针的指向
    return 0;
}
```
### 5.const 与 #define 的区别
**编译器处理方式不同**
define --> 在预处理阶段进行替换
const --> 在编译阶段确定其值

**类型检查**
define --> 无类型，不进行类型安全检查，可能会产生错误
const --> 有数据类型，编译时会检查

内存空间**
define --> 不分配内存，给出的是立即数，用了多少次就进行多少次替换，在内存中会有多个拷贝，消耗内存大
const --> 在静态存储区分配空间，程序运行中在内存中只有一次拷贝

在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储与读内存的操作，效率高。
宏替换只做替换，不做表达式计算。
# static
`static` 关键字用于声明**静态成员变量、静态成员函数和局部静态变量**，其作用取决于它所修饰的实体。

### 1. 静态成员变量（Static Member Variables）

静态成员变量是属于类的，而不是属于类的各个实例的。它的特点是所有类的实例共享同一份静态成员变量。静态成员变量可以通过类名直接访问，也可以通过对象访问。

```cpp
class MyClass {
public:
    static int count; // 声明静态成员变量
};

int MyClass::count = 0; // 初始化静态成员变量

int main() {
    MyClass obj1;
    MyClass obj2;
    
    obj1.count = 5; // 通过对象访问静态成员变量
    MyClass::count = 10; // 通过类名直接访问静态成员变量
    
    return 0;
}
```

### 2. 静态成员函数（Static Member Functions）

静态成员函数是属于类的函数，它不依赖于任何特定的对象。因此，它可以直接通过类名来调用，而不需要创建类的实例。

```cpp
class MyClass {
public:
    static void myStaticFunction() {
        // 静态成员函数的实现
    }
};

int main() {
    MyClass::myStaticFunction(); // 调用静态成员函数
    return 0;
}
```

### 3. 局部静态变量（Local Static Variables）

局部静态变量是在函数内部声明的静态变量，它具有静态生存期，即它在程序运行期间只初始化一次，并且在函数调用结束后仍然存在于内存中。

```cpp
void myFunction() {
    static int count = 0; // 声明局部静态变量
    count++;
    std::cout << "Count: " << count << std::endl;
}

int main() {
    myFunction();
    myFunction();
    myFunction();
    return 0;
}
```
### **1.作用范围**：

- `static` 关键字可以用于修饰变量、函数和类，它具有不同的作用效果。
- `const` 关键字用于声明常量，可以修饰变量、成员函数和指针。

### **2.作用时间**：

- `static` 关键字表示静态的特性，它的作用是在编译时期确定，程序运行过程中不会改变。
- `const` 关键字表示常量的特性，它的值在初始化后不能被修改。

### **3.内存分配**：

- `static` 修饰的静态变量在程序的静态存储区分配内存，它的生命周期贯穿整个程序的执行过程。
- `const` 修饰的常量可以是静态变量、全局变量、局部变量或者类的成员变量，其内存分配取决于其声明的位置和作用域。

### **4.用途**：

- `static` 用于实现静态成员变量、静态成员函数、局部静态变量等，通常用于共享数据和实现单例模式。
- `const` 用于声明常量，以及在成员函数中表明函数不会修改对象的状态，从而提高代码的安全性和可读性。




---
# volatile

对于 define 来说，宏定义实际上是在预编译阶段进⾏处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定 义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期 的效果。因为 define 宏定义仅仅是展开，因此运⾏时系统并不为宏定义分配内存，但是从汇编 的⻆度来讲， define 却以⽴即数的⽅式保留了多份数据的拷⻉。 对于 const 来说，const 是在编译期间进⾏处理的，const 有类型，也有类型检查，程序运⾏时系统会为 const 常 分配内存，⽽且从汇编的⻆度讲，const 常在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的 拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常分配内存，⽽是直接将 const 常添 加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。



static 作⽤：控制变的存储⽅式和可⻅性。 作⽤⼀：修饰局部变：⼀般情况下，对于局部变在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块 执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变便会存放在静态数据区，其⽣命周期会⼀直延续 到整个程序执⾏结束。但是要注意的是，虽然⽤ static 对局部变进⾏修饰之后，其⽣命周期以及存储空间发⽣了 变化，但其作⽤域并没有改变，作⽤域还是限制在其语句块。 作⽤⼆：修饰全部变：对于⼀个全局变，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被 访问(添加 extern进⾏声明即可)。⽤ static 对全局变进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成 了本⽂件可⻅。 作⽤三：修饰函数：⽤ static 修饰函数，情况和修饰全局变类似，也是改变了函数的作⽤域。 作⽤四：修饰类：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何 特定对象；如果对类中的某个变进⾏ static 修饰，则表示该变以及所有的对象所有，存储空间中只存在⼀个副 本，可以通过；类和对象去调⽤。 （补充：静态⾮常数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。） 作⽤五：类成员/类函数声明 static 函数体内 static 变的作⽤范围为该函数体，不同于 auto 变，该变的内存只被分配⼀次，因此其值在下 次调⽤时仍维持上次的值； 在模块内的 static 全局变可以被模块内所⽤函数访问，但不能被模块外其它函数访问； 在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内； 在类中的 static 成员变属于整个类所拥有，对类的所有对象只有⼀份拷⻉； 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变 。 static 类对象必须要在类外进⾏初始化，static 修饰的变先于对象存在，所以 static 修饰的变要在类外初 始化； 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本 对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰 的类成员； static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意 义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指 针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function。 const 关键字：含义及实现机制 const 修饰基本类型数据类型：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后， 其结果是⼀样的。在使⽤这些常的时候，只要不改变这些常的值即可。 const 修饰指针变和引⽤变：如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变，即指 针指向为常；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常。 const 应⽤到函数中：作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变初始化 const 常，则在函数体 中，按照 const 所修饰的部分进⾏常化，保护了原对象的属性。 [注意]：参数 const 通常⽤于参数为指针或引⽤ 的情况; 作为函数返回值的 const 修饰符：声明了返回值后，const 按照"修饰原则"进⾏修饰，起到相应的保护作 ⽤。 const 在类中的⽤法：const 成员变，只在某个对象⽣命周期内是常，⽽对于整个类⽽⾔是可以改变的。因为 类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员， 因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构 造函数的初始化列表中进⾏。const 成员函数：const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注 意，const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含 有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。 const 修饰类对象，定义常对象：常对象只能调⽤常函数，别的成员函数都不能调⽤。 补充：const 成员函数中如果实在想修改某个变，可以使⽤ mutable 进⾏修饰。成员变中如果想建⽴在整个类 中都恒定的常，应该⽤类中的枚举常来实现或者 static const。 C ++ 中的 const类成员函数（⽤法和意义） 常对象可以调⽤类中的 const 成员函数，但不能调⽤⾮ const 成员函数； （原因：对象调⽤成员函数时，在形 参列表的最前⾯加⼀个形参 this，但这是隐式的。this 指针是默认指向调⽤函数的当前对象的，所以，很⾃然， this 是⼀个常指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即⼩括号） 后加了 const 关键字（void print() const;），此成员函数为常成员函数，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值。 ⾮常对象可以调⽤类中的 const 成员函数，也可以调⽤⾮ const 成员函数。