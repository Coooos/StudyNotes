## inline用法
编译器工作时，以 .c 文件为单位逐个编译 .o 文件，每个 .c 文件的编译是独立的，如果 当前 .c 文件中要用到外部函数，那么就在编译时预留一个符号。等到所有 .o 文件生成后，链接时才给这些符号指定地址（链接脚本决定地址），所以这个 . c 文件编译时只会看到外部函数的声明而无法知道它的函数体。而内联函数声明时，加关键字 inline 修饰。调用到它的地方直接将汇编代码展开，而不需要通过符号（函数名）地址跳转。
### 内联函数

**在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。

为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。

栈空间就是指放置程序代码的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

### 代码用例

```c
#include <stdio.h>  
 
//函数定义为inline即:内联函数  
inline char* dbtest(int a) 
{  
	return (i % 2 > 0) ? "奇" : "偶";  
}   
  
int main()  
{  
	int i = 0;  
	for (i=1; i < 100; i++) 
	{  
		printf("i:%d    奇偶性:%s /n", i, dbtest(i));      
	}  
}
```

**其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2>0)?“奇”:“偶”，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。**

### 内联函数编程风格

#### 1、关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。

如下风格的函数Foo 不能成为内联函数：

```c
inline void Foo(int x, int y); // inline 仅与函数声明放在一起
void Foo(int x, int y)
{
}
```

而如下风格的函数Foo 则成为内联函数：

```c
void Foo(int x, int y);
inline void Foo(int x, int y) // inline 与函数定义体放在一起
{
}
```

所以说，inline 是一种 **“用于实现的关键字**” ，**而不是一种“用于声明的关键字”**。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：**声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联**。

#### 2、inline的使用是有所限制的

inline只适合**函数体内代码简单**的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是**直接递归函数**(自己内部还调用自己的函数)。

#### 3、慎用内联

内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？

**内联是以代码膨胀（复制）为代价**，仅仅省去了函数调用的开销，从而提高函数的执行效率。**如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少**。另一方面，**每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。**

以下情况不宜使用内联：

（1）如果函数体内的**代码比较长**，使用内联将导致内存消耗代价较高。

（2）如果函数体内**出现循环**，那么执行函数体内代码的时间要比函数调用的开销大。

一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。

#### 4、将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦

而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为。

## extern用法

利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数，下面就结合具体的实例，分类说明一下。

### 一、引用同一个文件中的变量

```c
#include<stdio.h>

int func();

int main()
{
    func(); //1
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}

```

如果按照这个顺序，变量 num在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用num这个变量的，因为当编译器编译到这一句话的时候，找不到num这个变量的声明，但是在func函数中是可以正常使用，因为func对num的调用是发生在num的声明和初始化之后。

如果我不想改变num的声明的位置，但是想在main函数中直接使用num这个变量，怎么办呢？可以使用extern这个关键字。像下面这一段代码，利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。但是你要是想欺骗编译器也是不行的，比如你声明了extern int num；但是在后面却没有真正的给出num变量的声明，那么编译器去别的地方找了，但是没找到还是不行的。

下面的程序就是利用extern关键字，使用在后边定义的变量。

```c
#include<stdio.h>

int func();

int main()
{
    func(); //1
    extern int num;
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}

```

### 二、引用另一个文件中的变量

如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。  
extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数。  
**main.c**

```c
#include<stdio.h>

int main()
{
    extern int num;
    printf("%d",num);
    return 0;
}
```

**b.c**

```c
#include<stdio.h>

int num = 5;

void func()
{
    printf("fun in a.c");
}

```

例如，这里b.c中定义了一个变量num，如果main.c中想要引用这个变量，那么可以使用extern这个关键字，注意这里能成功引用的原因是，num这个关键字在b.c中是一个全局变量，也就是说只有当一个变量是一个全局变量时，extern变量才会起作用。

另外，extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0。

像这种写法是不行的。  
`extern int num=4;`  
但是在声明之后就可以使用变量名进行修改了。

```c
#include<stdio.h>

int main()
{
    extern int num;
    num=1;
    printf("%d",num);
    return 0;
}

```

使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好。

### 引用另一个文件中的函数

extern除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似。  
mian.c

```c
#include<stdio.h>

int main()
{
    extern void func();
    func();
    return 0;
}
```

b.c

```c
#include<stdio.h>

const int num=5;
void func()
{
    printf("fun in a.c");
}
```

这里main函数中引用了b.c中的函数func。因为所有的函数都是全局的，所以对函数的extern用法和对全局变量的修饰基本相同，需要注意的就是，需要指明返回值的类型和参数。
### 区别
| 特性         | `inline`                               | `extern`                  |
| ---------- | -------------------------------------- | ------------------------- |
| **用途**     | 建议编译器将函数调用替换为函数主体代码，以优化性能。             | 声明变量或函数在其他文件中定义，用于跨文件链接。  |
| **作用对象**   | 函数。                                    | 变量或函数。                    |
| **使用位置**   | 函数定义。                                  | 变量或函数声明。                  |
| **对链接的影响** | 编译器可能将多个 `inline` 函数的定义合并为一个，避免重复符号错误。 | 告诉编译器变量或函数在其他地方定义，避免链接错误。 |
| **性能影响**   | 可能提高性能，减少函数调用开销。                       | 无直接影响，主要用于链接阶段。           |
