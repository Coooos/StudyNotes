[Hello 算法](https://www.hello-algo.com/)

https://blog.csdn.net/ityqing/article/details/82838524](https://blog.csdn.net/ityqing/article/details/82838524)

[https://www.zhihu.com/search?q=%E5%90%84%E7%B1%BB%E7%AE%97%E6%B3%95&search_source=History&utm_content=search_history&type=content](https://www.zhihu.com/search?q=%E5%90%84%E7%B1%BB%E7%AE%97%E6%B3%95&search_source=History&utm_content=search_history&type=content)

---

### **1. 分治算法（Divide and Conquer）**[分治算法](分治算法.md)

#### **核心思想**  
将问题分解为多个**独立**的子问题，递归求解后合并结果。  
**关键特点**：子问题无重叠，必须可合并。  
#### **优点**  
- 逻辑清晰，简化复杂问题（如归并排序）。  
- 适合并行计算（子问题独立）。  
#### **缺点**  
- 递归开销大，可能栈溢出。  
- 子问题重复计算时效率低（无记忆化）。  
#### **典型应用**  
归并排序、快速排序、二分查找、大整数乘法。  

---

### 2. 回溯算法（Backtracking） [回溯算法](回溯算法.md)


#### **核心思想**  
通过递归/迭代穷举所有可能解，遇到无效解时回退（“试错”），通过**剪枝**减少搜索。  
**关键特点**：系统性搜索解空间，类似DFS+剪枝。  
#### **优点**  
- 能解决复杂约束问题（如排列、组合、棋盘类）。  
- 通用性强，适合穷举场景。  
#### **缺点**  
- 时间复杂度高（如O(n!)），需依赖剪枝优化。  
- 递归深度大时效率低。  
#### **典型应用**  
N皇后、数独、全排列、组合求和、图的哈密顿路径。  

---

### **3. 动态规划（Dynamic Programming, DP）**[动态规划](动态规划.md)

#### **核心思想**  
将问题分解为**重叠子问题**，通过记忆化（表格或备忘录）避免重复计算，自底向上递推。  
**关键特点**：最优子结构 + 重叠子问题。  
#### **优点**  
- 避免重复计算，显著提升效率（如斐波那契数列从O(2^n)到O(n)）。  
- 解决多阶段决策问题（如背包、路径规划）。  
#### **缺点**  
- 需额外空间存储状态（如O(n²)的DP表）。  
- 设计状态转移方程难度大。  
#### **典型应用**  
0-1背包、最长公共子序列（LCS）、最短路径（Floyd）、股票买卖问题。  

---

### **4. 贪心算法（Greedy）****[贪心算法](贪心算法.md)

#### **核心思想**  
每一步选择当前**局部最优解**，希望达到全局最优。  
**关键特点**：不可回退，需问题具有贪心选择性质。  
#### **优点**  
- 高效，时间复杂度通常较低（如O(n log n)）。  
- 代码简单，适合实时系统。  
#### **缺点**  
- **不保证全局最优**（需数学证明贪心策略有效）。  
- 应用场景有限。  
#### **典型应用**  
Dijkstra算法、霍夫曼编码、区间调度、分数背包问题。  

---

### **对比总结表**

- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。

- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。

- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。

实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性。

| **算法**   | **时间复杂度**    | **空间复杂度**  | **核心特点**      | **适用场景**         | **是否全局最优** | 思维方式           |
| -------- | ------------ | ---------- | ------------- | ---------------- | ---------- | -------------- |
| **分治**   | 依赖子问题划分      | O(递归栈)     | 子问题独立，需合并     | 排序、二分、独立子问题      | ✅          | 自顶向下（递归）       |
| **回溯**   | 指数级（如O(n!)）  | O(递归深度)    | 穷举+剪枝，可处理复杂约束 | 排列、组合、棋盘类        | ✅（需穷举）     |                |
| **动态规划** | 多项式级（如O(n²)） | O(n²)或O(n) | 重叠子问题，记忆化递推   | 最优解问题（背包、路径、序列）  | ✅          | **自底向上**（迭代递推） |
| **贪心**   | 通常O(n log n) | O(1)或O(n)  | 局部最优，不可回退     | 调度、最短路径（需满足贪心性质） | ❌（可能局部最优）  |                |


---

### **如何选择算法？**  
1. **问题是否需穷举所有解？**  
   - 是 → **回溯**（如N皇后）。  
   - 否 → 下一步。  
2. **子问题是否重叠？**  
   - 是 → **动态规划**（如斐波那契）。  
   - 否 → **分治**（如归并排序）。  
3. **能否用局部最优推导全局最优？**  
   - 是 → **贪心**（如Dijkstra）。  
   - 否 → 回溯或DP。  

---

### **经典问题对比**  
- **最短路径问题**：  
  - 贪心：Dijkstra（无负权边）。  
  - DP：Floyd（任意两点间最短路径）。  
- **背包问题**：  
  - 贪心：分数背包（按性价比贪心）。  
  - DP：0-1背包（需状态转移方程）。  

---

### **总结**  
- **分治**：子问题独立，递归分治再合并。  
- **回溯**：暴力穷举+剪枝，适合复杂约束。  
- **DP**：重叠子问题+记忆化，优化递归问题。  
- **贪心**：局部最优快，但需验证全局最优性。  