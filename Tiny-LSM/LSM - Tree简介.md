
 [Lab 介绍 - Tiny-LSM-Lab](https://vanilla-beauty.github.io/tiny-lsm/book/introduction.html)

[一文搞懂LSM-Tree - 乂墨EMO - 博客园](https://www.cnblogs.com/zxporz/p/16021373.html)

[(8 封私信 / 38 条消息) LSM树详解 - 知乎](https://zhuanlan.zhihu.com/p/181498475)

---

你可以把 LSM-Tree 想象成一个 **“不断整理、归档的超级收纳师”**。

它的核心目的就一个：**为了飞快地写入数据**。

---

### 一、它解决了什么问题？

想象一个传统数据库（比如最常见的 B-Tree），它像一本**内容精美的精装书**。
*   **写入（Write）**：就像你要在这本书的某一页中间插入一句话，你可能需要重新排版、调整目录，非常**慢**。
*   **读取（Read）**：但读起来很快，因为有目录（索引），直接翻到那一页就行。

如果每秒有海量数据要写入（比如监控日志、聊天记录），这种“精装书”就忙不过来了，写入会成为瓶颈。LSM-Tree 就是为了解决这个“写得太慢”的问题而生的。

---

### 二、Tiny LSM-Tree 的工作流程（超级收纳法）

这个“超级收纳师”的工作方法非常简单粗暴，就两步：

#### 第1步：来者不拒，先放“桌面”（MemTable - 内存表）

*   **所有新来的数据**（插入、更新、删除），先不急着整理到“书柜”里。而是随手扔在**内存**中的一个“桌面”上。这个桌面就叫 **MemTable**。
*   **为啥快？** 因为写内存的速度比写硬盘快成千上万倍！所以写入操作瞬间就完成了，用户体验极好。

#### 第2步：定期整理，归档入“柜”（SSTable - 有序字符串表）

*   当“桌面”（MemTable）上的数据堆到一定大小后，收纳师就开始工作了。
*   他会把桌面上所有的数据：
    1.  **排序**：按照键（Key）的大小整理得井然有序。
    2.  **打包**：把这些排好序的数据打包成一个文件。这个文件就叫 **SSTable**。
    3.  **入柜**：把这个 SSTable 文件存到**硬盘**里。硬盘就是你的“书柜”。
*   这样，内存中的“桌面”又被清空了，可以继续高速接收新数据。

**这个过程会不断重复：写满一个 MemTable，就打包成一个 SSTable 存入磁盘。所以你的硬盘里最终会有很多个 SSTable 文件。**

---

### 三、怎么读数据？（收纳师的查找技巧）

现在数据分散在“桌面”（MemTable）和“书柜”的很多个 SSTable 文件里，怎么读呢？收纳师有自己的方法：

1.  **先看桌面**：首先在最新的 MemTable 里找有没有这个数据。
2.  **再翻柜子**：如果没找到，就从**最新的 SSTable 文件开始，由新到旧**一个一个文件地找。
    *   **为什么从新到旧？** 因为新的数据会覆盖旧的数据（比如你修改了某个键的值），一旦在新的 SSTable 里找到了，就不用去旧的里面翻了，保证了能读到最新的值。
3.  **Bloom Filter（布隆过滤器） - 收纳师的智能标签**：
    *   逐个翻 SSTable 文件还是很慢怎么办？高级的 LSM-Tree 会给每个 SSTable 文件贴一个“智能标签”（Bloom Filter）。
    *   在翻柜子之前，先问一下这个标签：“你这个文件里有 `key=123` 这个东西吗？”
    *   标签会回答：“**肯定没有**” 或 “**可能有**”。
    *   如果标签说“肯定没有”，收纳师就根本不用打开这个文件了，省去了大量无效的查找时间！这是一个用少量空间换取巨大性能提升的神器。

---

### 四、压缩（Compaction）- 终极整理术

时间长了，“书柜”里的 SSTable 文件越来越多，而且不同文件里可能还有重复的、过时的数据。这时候就需要“大扫除”——这就是**压缩**。

*   压缩过程会把多个小的、旧的 SSTable 文件合并成一个大的、新的 SSTable 文件。
*   在合并的过程中，会**丢弃掉被覆盖的旧值**和**标记为删除的数据**。
*   这样既减少了文件数量，又释放了磁盘空间，让读取效率更高。

---

### 学习 Tiny LSM-Tree 项目的重点

你看的这个“Tiny”项目，通常会包含以上最核心的组件，是理解巨无霸（如 LevelDB, RocksDB）的完美起点。你应该重点关注它如何实现这几个部分：

| 组件 | 是干什么的？ | 你可能会在代码里看到什么？ |
| :--- | :--- | :--- |
| **MemTable** | 在内存中临时存数据的结构 | 很可能用一个**跳表（SkipList）** 或 **平衡二叉树** 来实现，因为它要支持高效的范围查询。 |
| **SSTable** | 磁盘上排好序的不可变数据文件 | `.sst` 后缀的文件。结构通常是：**数据块 + 索引块 + Bloom Filter位图**。 |
| **WAL (Write-Ahead Log)** | **很重要！** 为了防止内存中的数据丢失，在写 MemTable 之前会先写一条日志到磁盘。 | 一个只追加（append-only）的日志文件（如 `.log`）。系统重启后靠它来恢复MemTable。 |
| **Compaction** | 合并和清理SSTable文件的策略 | 代码里最复杂的部分之一。会有一个策略来决定何时以及如何合并哪些SSTable。 |

### 总结

*   **核心思想**：**“先写内存，后刷磁盘”**。用顺序写磁盘（追加SSTable）代替随机写磁盘，从而换取极高的写入吞吐量。
*   ** trade-off (权衡)**：**用读的性能换写的性能**。写入极快，但读取可能较慢（因为要查多个地方）。通过 Bloom Filter 和 Compaction 来优化读。
*   **应用场景**：所有需要超高写入速度的地方，比如：**大数据系统（HBase）、监控日志、消息队列、区块链**等等。
