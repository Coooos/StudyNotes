# 分治算法

难题被逐层拆解，每一次的拆解都使它变得更为简单。

分而治之揭示了一个重要的事实：从简单做起，一切都不再复杂。

[https://www.hello-algo.com/chapter_divide_and_conquer/](https://www.hello-algo.com/chapter_divide_and_conquer/)

---

## **1. 分治算法的核心思想**

分治（Divide and Conquer）是一种**递归式问题解决策略**，其核心思想是：

1. **分（Divide）**：将原问题分解为若干个**规模更小、结构相同**的子问题。
2. **治（Conquer）**：递归地解决这些子问题。如果子问题足够小，则直接求解。
3. **合（Combine）**：将子问题的解**合并**，得到原问题的解。

### **🔹** **我的观点**

分治算法的关键在于**如何有效地分解问题**。如果分解方式不合理，可能会导致递归层数过深，甚至无法合并解。例如，在快速排序中，如果选择的基准（pivot）总是极端值，分治就会退化成 O(n²) 的时间复杂度。

---

## **2. 分治算法的适用条件**

分治算法**并非适用于所有问题**，通常适用于以下情况：

1. **问题可分解**：可以分解为若干个**相似且独立**的子问题。

- _反例_：动态规划问题通常有重叠子问题，不适合纯分治。

2. **子问题的解可合并**：子问题的解能组合成原问题的解。

- _反例_：某些优化问题的最优解不能由子问题直接合并，如旅行商问题（TSP）。

3. **递归终止条件明确**：必须有明确的**基本情况（Base Case）**，防止无限递归。

### **🔹** **我的观点**

分治算法在**数据规模较大且可分解**时表现优异，例如排序、搜索、矩阵乘法等。但**递归带来的栈开销**可能影响性能，有时需要用**迭代+栈**的方式优化（如非递归的快速排序）。

---

## **3. 分治算法的经典应用**

### **(1) 归并排序（Merge Sort）**

- **分解**：将数组分成两半。
- **解决**：递归排序左右两半。
- **合并**：合并两个有序子数组。
- **时间复杂度**：O(n log n)，稳定排序。

### **(2) 快速排序（Quick Sort）**

- **分解**：选择基准（pivot），将数组分为 `< pivot` 和 `≥ pivot` 两部分。
- **解决**：递归排序左右部分。
- **合并**：无需合并，因为原地排序。
- **时间复杂度**：

- 平均：O(n log n)
- 最坏（已排序数组+最差pivot选择）：O(n²)

### **(3) 二分查找（Binary Search）**

- **分解**：比较中间元素，决定向左或向右搜索。
- **解决**：递归或迭代地在子区间查找。
- **合并**：无（直接返回结果）。
- **时间复杂度**：O(log n)。

### **(4) 汉诺塔问题**

- **分解**：将 n 个盘子从 A 移到 C，分解为：

1. 将 n-1 个盘子从 A 移到 B（借助 C）。
2. 将第 n 个盘子从 A 移到 C。
3. 将 n-1 个盘子从 B 移到 C（借助 A）。

- **时间复杂度**：O(2ⁿ)，因为每次分解成 2 个子问题。

### **(5) 最大子数组问题（Maximum Subarray）**

- **分解**：将数组分成左右两半。
- **解决**：

- 计算左半部分的最大子数组。
- 计算右半部分的最大子数组。
- 计算跨越中点的最大子数组。

- **合并**：取三者中的最大值。
- **时间复杂度**：O(n log n)（比动态规划的 O(n) 稍慢）。

---

## **4. 分治算法的优化**

### **(1) 尾递归优化**

- 某些分治算法（如二分查找）可以改写成**尾递归**，减少栈开销。
- 部分编译器（如 GCC）会优化尾递归为循环。

### **(2) 迭代代替递归**

- 例如，快速排序可以用**栈+循环**实现，避免递归过深。

### **(3) 并行化分治**

- 分治的子问题通常是独立的，适合**多线程/分布式计算**。
- 例如，MapReduce 就是分治思想的大规模应用。

---

## **5. 总结**

- **分治的核心**：分解 → 解决 → 合并。
- **适用场景**：问题可分解、子问题独立、解可合并。
- **经典应用**：排序（归并、快排）、搜索（二分）、汉诺塔、最近点对。
- **优化方式**：尾递归、迭代实现、并行计算。
- **对比其他算法**：

- 分治 vs. 动态规划 → 子问题是否重叠。
- 分治 vs. 贪心 → 是否需要全局最优。


# **分治算法 vs. 回溯算法：区别与联系**

## **1. 核心思想对比**

|   |   |   |
|---|---|---|
|特性|分治算法 (Divide & Conquer)|回溯算法 (Backtracking)|
|**目标**|**分解问题，合并子问题的解**|**尝试所有可能的解，剪枝无效路径**|
|**策略**|递归分解 → 独立求解 → 合并结果|递归尝试 → 失败回退 → 换路径尝试|
|**关键操作**|分、治、合|选择、约束、回溯|

### **🔹** **我的观点**

分治算法是**“正向分解”**，而回溯算法是**“试探性搜索”**。分治像流水线作业，回溯像走迷宫——不断试错，后退再选新路。

---

## **2. 相似之处**

### **(1) 均基于递归**

- 两者都依赖**递归**实现子问题的分解或路径的探索。
- 例如：

- 分治：归并排序递归拆分数组。
- 回溯：八皇后问题递归尝试每一行的放置。

### **(2) 都需要明确的终止条件**

- 分治的**Base Case**（如数组长度为1时直接返回）。
- 回溯的**终止条件**（如找到解或无路可走时回退）。

### **(3) 解决复杂问题**

- 均适用于**问题规模较大**的场景，通过分解或剪枝降低复杂度。

---

## **3. 核心区别**

|   |   |   |
|---|---|---|
|对比维度|分治算法|回溯算法|
|**子问题关系**|子问题**独立**，无重叠|子问题**依赖前序选择**，可能重叠|
|**解的处理**|子问题的解**必须合并**|解是**逐步构建**的，失败则丢弃|
|**时间复杂度**|通常更高效（如归并排序O(n log n))|可能较高（如全排列O(n!)）|
|**典型应用**|排序、搜索、数学计算|排列组合、约束满足、棋盘类问题|

### **🔹** **关键区别示例**

1. **快速排序（分治）**：

- 分解：按pivot分成左右两部分。
- 子问题：左右部分的排序互不影响。
- 合并：天然有序，无需额外操作。

2. **N皇后问题（回溯）**：

- 尝试：在当前行放置皇后，检查冲突。
- 回溯：若冲突，撤销选择并尝试下一列。
- 解：所有行放置成功后才算最终解。

---

## **4. 从代码结构看区别**

### **分治算法模板（以归并排序为例）**

```
def divide_and_conquer(nums):
    # 1. Base Case
    if len(nums) <= 1:
        return nums
    
    # 2. Divide
    mid = len(nums) // 2
    left = divide_and_conquer(nums[:mid])
    right = divide_and_conquer(nums[mid:])
    
    # 3. Combine
    return merge(left, right)
```

### **回溯算法模板（以全排列为例）**

```
def backtrack(path, choices):
    # 1. 终止条件
    if len(path) == len(choices):
        results.append(path.copy())
        return
    
    # 2. 遍历选择
    for num in choices:
        if num in path:  # 剪枝：跳过无效选择
            continue
        path.append(num)  # 尝试选择
        backtrack(path, choices)
        path.pop()       # 回溯：撤销选择
```

### **🔹** **我的观点**

分治的代码更**结构化**（分→治→合），而回溯的代码更**灵活**（尝试→回退）。回溯的`pop()`操作是分治没有的，体现了“撤销”的核心逻辑。

---

## **5. 边界案例：分治与回溯的结合**

某些问题可能同时用到两种策略：

- **例如**：求解**最近点对问题**（Closest Pair）：

1. **分治**：将点集分成左右两半。
2. **回溯**：合并时检查跨左右边界的点对是否更近。

### **🔹** **我的观点**

算法分类并非绝对，实际应用中可能混合多种策略。理解本质（分解 vs. 试探）比死记定义更重要。

---

## **6. 如何选择？**

- **用分治**：

- 问题可明确分解为独立子问题。
- 子问题的解能高效合并（如排序、数学计算）。

- **用回溯**：

- 问题需要**穷举所有可能性**（如排列、组合）。
- 存在**约束条件**可剪枝（如数独、N皇后）。

---

## **7. 总结**

|   |   |   |
|---|---|---|
|**维度**|**分治算法**|**回溯算法**|
|**本质**|分解→解决→合并|尝试→失败→回溯|
|**子问题**|独立，无重叠|依赖前序选择，可能重叠|
|**解的处理**|必须合并子解|逐步构建，失败则丢弃|
|**适用场景**|排序、搜索、数学问题|排列组合、棋盘类、约束满足问题|
|**时间复杂度**|通常较低（如O(n log n)）|可能较高（如O(n!)）|

### **🔹** **最终建议**

- 若问题像**“拆积木”**（子问题明确且独立），用分治。
- 若问题像**“走迷宫”**（需试错和回退），用回溯。
- 两者都依赖递归，但**回溯更强调“撤销操作”**，这是最显著的区别。


### **4. 分治 vs. 动态规划 vs. 贪心**

|          |             |             |                   |
| -------- | ----------- | ----------- | ----------------- |
| 算法策略     | 特点          | 适用场景        | 经典问题              |
| **分治**   | 子问题独立，递归分解  | 可分解且可合并的问题  | 归并排序、快速排序、汉诺塔     |
| **动态规划** | 子问题重叠，记忆化存储 | 最优子结构+重叠子问题 | 背包问题、斐波那契、最短路径    |
| **贪心**   | 局部最优选择，不回溯  | 问题具有贪心选择性质  | 霍夫曼编码、Dijkstra 算法 |
|          |             |             |                   |

### **🔹** **我的观点**

- **分治适合“分而治之”的问题**，如排序、搜索。
- **动态规划适合“重叠子问题”问题**，如最短路径、序列比对。
- **贪心适合“局部最优能推导全局最优”的问题**，如任务调度、最小生成树（Prim/Kruskal）。