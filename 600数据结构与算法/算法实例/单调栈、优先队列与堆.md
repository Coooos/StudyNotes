# **单调栈、优先队列与堆的详细解析与C++实现**

## **1. 单调栈 (Monotonic Stack)**

### **1.1 基本概念**
单调栈是一种特殊的栈结构，它保持栈内元素的单调性（单调递增或单调递减）。主要用于解决需要找到某个元素的下一个更大/更小元素的问题。

### **1.2 核心特点**
- **单调性维护**：栈内元素始终保持单调递增或单调递减
- **高效性**：每个元素最多入栈和出栈一次，时间复杂度O(n)
- **典型应用**：
  - 下一个更大/更小元素问题
  - 直方图最大矩形面积
  - 滑动窗口最大值

### **1.3 C++实现**

#### **(1) 下一个更大元素**
```cpp
#include <vector>
#include <stack>

std::vector<int> nextGreaterElement(const std::vector<int>& nums) {
    std::vector<int> res(nums.size(), -1);  // 初始化结果数组
    std::stack<int> st;  // 存储元素索引
    
    for (int i = 0; i < nums.size(); ++i) {
        // 维护单调递减栈
        while (!st.empty() && nums[i] > nums[st.top()]) {
            res[st.top()] = nums[i];  // 找到栈顶元素的下一个更大元素
            st.pop();
        }
        st.push(i);  // 压入当前元素索引
    }
    return res;
}

// 示例用法
int main() {
    std::vector<int> nums = {2, 1, 2, 4, 3};
    auto result = nextGreaterElement(nums);
    // 输出: [4, 2, 4, -1, -1]
    return 0;
}
```

#### **(2) 直方图最大矩形**
```cpp
#include <vector>
#include <stack>
#include <algorithm>

int largestRectangleArea(std::vector<int>& heights) {
    heights.push_back(0);  // 添加哨兵值确保所有元素出栈
    std::stack<int> st;
    int max_area = 0;
    
    for (int i = 0; i < heights.size(); ++i) {
        // 维护单调递增栈
        while (!st.empty() && heights[i] < heights[st.top()]) {
            int h = heights[st.top()];
            st.pop();
            // 计算宽度：当前索引 - 新栈顶索引 - 1
            int w = st.empty() ? i : i - st.top() - 1;
            max_area = std::max(max_area, h * w);
        }
        st.push(i);
    }
    return max_area;
}

// 示例用法
int main() {
    std::vector<int> heights = {2, 1, 5, 6, 2, 3};
    int area = largestRectangleArea(heights);
    // 输出: 10 (对应高度5和6的两个矩形)
    return 0;
}
```

## **2. 优先队列 (Priority Queue)**

### **2.1 基本概念**
优先队列是一种抽象数据结构，元素按照优先级顺序出队，而非FIFO顺序。通常用堆实现。

### **2.2 核心特点**
- **优先级排序**：最高/最低优先级元素先出队
- **高效操作**：
  - 插入/删除：O(log n)
  - 查看顶部元素：O(1)
- **典型应用**：
  - Dijkstra算法
  - 合并K个有序链表
  - 任务调度

1. **比较函数的方向**：
   - `a < b` → 最大堆（默认）
   - `a > b` → 最小堆

2. **稳定性问题**：
   - 堆不是稳定排序，相同优先级元素的顺序可能变化

3. **性能考虑**：
   - 使用lambda时，`decltype`可以避免类型重复
   - 复杂比较函数可能影响性能

4. **STL容器选择**：
   - `std::priority_queue`不能随机访问
   - 需要随机访问时用`std::vector`+堆算法

### **2.3 C++实现**

#### **(1) 基本用法**
```cpp
#include <queue>
#include <iostream>

int main() {
    // 默认最大堆
    std::priority_queue<int> max_heap;
    max_heap.push(3);
    max_heap.push(1);
    max_heap.push(4);
    std::cout << "Max heap top: " << max_heap.top() << "\n";  // 输出4

    // 最小堆
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
    min_heap.push(3);
    min_heap.push(1);
    min_heap.push(4);
    std::cout << "Min heap top: " << min_heap.top() << "\n";  // 输出1

    return 0;
}
```

#### **(2) 自定义优先级**
```cpp
#include <queue>
#include <vector>

struct Task {
    int priority;
    std::string name;
    
    // 重载<运算符实现最大堆
    bool operator<(const Task& other) const {
        return priority < other.priority;
    }
};

int main() {
    std::priority_queue<Task> task_queue;
    task_queue.push({3, "High priority"});
    task_queue.push({1, "Low priority"});
    task_queue.push({2, "Medium priority"});
    
    while (!task_queue.empty()) {
        auto task = task_queue.top();
        std::cout << task.name << "\n";
        task_queue.pop();
    }
    // 输出顺序: High -> Medium -> Low
    return 0;
}
```

## **3. 堆 (Heap)**

### **3.1 基本概念**
堆是一种完全二叉树，满足堆性质：
- 最大堆：父节点 ≥ 子节点
- 最小堆：父节点 ≤ 子节点

### **3.2 核心特点**
- **高效操作**：
  - 插入/删除：O(log n)
  - 建堆：O(n)
- **典型应用**：
  - 堆排序
  - Top K问题
  - 优先队列实现

### **3.3 C++实现**

#### **(1) 使用STL堆算法**
```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    std::vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};
    
    // 构建最大堆
    std::make_heap(nums.begin(), nums.end());
    std::cout << "Heap top: " << nums.front() << "\n";  // 9
    
    // 插入元素
    nums.push_back(8);
    std::push_heap(nums.begin(), nums.end());
    std::cout << "After push: " << nums.front() << "\n";  // 9
    
    // 弹出堆顶
    std::pop_heap(nums.begin(), nums.end());
    nums.pop_back();
    std::cout << "After pop: " << nums.front() << "\n";  // 8
    
    return 0;
}
```

#### **(2) 堆排序实现**
```cpp
#include <vector>
#include <algorithm>

void heapSort(std::vector<int>& nums) {
    // 建堆
    std::make_heap(nums.begin(), nums.end());
    
    // 依次取出最大值放到末尾
    for (int i = nums.size() - 1; i > 0; --i) {
        std::swap(nums[0], nums[i]);
        // 重新调整堆范围
        std::make_heap(nums.begin(), nums.begin() + i);
    }
}

// 示例用法
int main() {
    std::vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};
    heapSort(nums);
    // 排序后: [1, 1, 2, 3, 4, 5, 6, 9]
    return 0;
}
```

## **5. 进阶应用示例**

### **5.1 合并K个有序链表（优先队列实现）**
```cpp
#include <queue>
#include <vector>

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

struct Compare {
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;  // 最小堆
    }
};

ListNode* mergeKLists(std::vector<ListNode*>& lists) {
    std::priority_queue<ListNode*, std::vector<ListNode*>, Compare> pq;
    
    // 将所有链表的头节点加入优先队列
    for (auto list : lists) {
        if (list) pq.push(list);
    }
    
    ListNode dummy(0);
    ListNode* tail = &dummy;
    
    while (!pq.empty()) {
        auto node = pq.top();
        pq.pop();
        tail->next = node;
        tail = tail->next;
        if (node->next) pq.push(node->next);
    }
    
    return dummy.next;
}
```

### **5.2 滑动窗口最大值（单调队列实现）**
```cpp
#include <vector>
#include <deque>

std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
    std::vector<int> res;
    std::deque<int> dq;  // 存储索引
    
    for (int i = 0; i < nums.size(); ++i) {
        // 移除超出窗口范围的元素
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // 维护单调递减队列
        while (!dq.empty() && nums[i] >= nums[dq.back()]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // 窗口形成后记录最大值
        if (i >= k - 1) {
            res.push_back(nums[dq.front()]);
        }
    }
    
    return res;
}
```


## **6. 自定义优先级的4种实现方式**

堆是一种完全二叉树，满足：
- **最大堆**：父节点 ≥ 子节点（根节点最大）
- **最小堆**：父节点 ≤ 子节点（根节点最小）

C++中可以通过：
- `std::priority_queue`（优先队列，默认最大堆）
- `std::make_heap`/`push_heap`/`pop_heap`（底层堆算法）

### **2.1 方式1：重载<运算符（推荐）**
```cpp
#include <queue>
#include <iostream>

struct Node {
    int value;
    Node(int v) : value(v) {}
    
    // 重载<运算符（最大堆）
    bool operator<(const Node& other) const {
        return value < other.value; // "＜"建最大堆
    }
    
    /* 最小堆写法：
    bool operator<(const Node& other) const {
        return value > other.value; // "＞"建最小堆
    }
    */
};

int main() {
    std::priority_queue<Node> max_heap;
    max_heap.push(Node(3));
    max_heap.push(Node(1));
    max_heap.push(Node(4));
    
    while (!max_heap.empty()) {
        std::cout << max_heap.top().value << " "; // 输出：4 3 1
        max_heap.pop();
    }
    return 0;
}
```

### **2.2 方式2：使用比较函数对象**
```cpp
#include <queue>
#include <vector>

struct Person {
    std::string name;
    int age;
};

// 自定义比较函数对象
struct CompareAge {
    bool operator()(const Person& a, const Person& b) const {
        return a.age < b.age; // 年龄大的优先级高（最大堆）
    }
};

int main() {
    std::priority_queue<Person, std::vector<Person>, CompareAge> pq;
    
    pq.push({"Alice", 25});
    pq.push({"Bob", 30});
    pq.push({"Charlie", 20});
    
    while (!pq.empty()) {
        auto p = pq.top();
        std::cout << p.name << "(" << p.age << ") ";
        pq.pop();
    }
    // 输出：Bob(30) Alice(25) Charlie(20)
    return 0;
}
```

### **2.3 方式3：使用lambda表达式（C++11+）**
```cpp
#include <queue>
#include <vector>
#include <functional> // for std::function

struct Task {
    int priority;
    std::string name;
};

int main() {
    // 使用lambda定义最小堆
    auto cmp = [](const Task& a, const Task& b) {
        return a.priority > b.priority; // ">"是最小堆
    };
    
    // 注意：需要指定底层容器和比较器类型
    std::priority_queue<Task, std::vector<Task>, decltype(cmp)> pq(cmp);
    
    pq.push({3, "Low"});
    pq.push({1, "High"});
    pq.push({2, "Medium"});
    
    while (!pq.empty()) {
        auto t = pq.top();
        std::cout << t.name << " ";
        pq.pop();
    }
    // 输出：High Medium Low
    return 0;
}
```

### **2.4 方式4：使用std::greater/std::less（内置比较器）**
```cpp
#include <queue>
#include <vector>

// 内置比较器（适用于基本类型）
int main() {
    // 最小堆
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;
    min_heap.push(3);
    min_heap.push(1);
    min_heap.push(4);
    
    // 输出：1 3 4
    while (!min_heap.empty()) {
        std::cout << min_heap.top() << " ";
        min_heap.pop();
    }
    return 0;
}
```

## **7. 底层堆算法的自定义优先级**
如果直接使用`std::make_heap`等算法：

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

struct Point {
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

int main() {
    std::vector<Point> points = {{1,2}, {3,1}, {2,3}};
    
    // 按x坐标建最大堆
    auto cmp = [](const Point& a, const Point& b) {
        return a.x < b.x; // "<"是最大堆
    };
    
    std::make_heap(points.begin(), points.end(), cmp);
    
    // 堆顶是{3,1}
    std::cout << "Top: (" << points[0].x << "," << points[0].y << ")\n";
    
    // 插入新元素
    points.push_back({4,0});
    std::push_heap(points.begin(), points.end(), cmp);
    
    // 新的堆顶是{4,0}
    std::cout << "New top: (" << points[0].x << "," << points[0].y << ")\n";
    
    return 0;
}
```


## **8. 实际应用示例**
### **5.1 任务调度系统**
```cpp
struct Task {
    int priority;
    std::string id;
    time_t deadline;
    
    // 先按优先级，再按截止时间
    bool operator<(const Task& other) const {
        if (priority != other.priority)
            return priority < other.priority; // 高优先级先执行
        return deadline > other.deadline;    // 同优先级则早截止的先执行
    }
};

void taskScheduler() {
    std::priority_queue<Task> queue;
    queue.push({3, "T1", 1630000000});
    queue.push({1, "T2", 1630001000});
    queue.push({1, "T3", 1630000500});
    
    while (!queue.empty()) {
        auto task = queue.top();
        std::cout << "Executing: " << task.id << "\n";
        queue.pop();
    }
    /* 输出顺序：
    Executing: T2 (最高优先级)
    Executing: T3 (同优先级但截止更早)
    Executing: T1
    */
}
```

### **5.2 股票交易系统（价格-时间优先级）**
```cpp
struct Order {
    double price;
    int quantity;
    long timestamp; // 下单时间
    
    // 买单：价格高的优先，同价格则早到的优先
    static bool buyComparator(const Order& a, const Order& b) {
        if (a.price != b.price)
            return a.price < b.price; // 价格高的在前
        return a.timestamp > b.timestamp; // 时间早的在前
    }
    
    // 卖单：价格低的优先，同价格则早到的优先
    static bool sellComparator(const Order& a, const Order& b) {
        if (a.price != b.price)
            return a.price > b.price; // 价格低的在前
        return a.timestamp > b.timestamp; // 时间早的在前
    }
};

class TradingSystem {
    std::priority_queue<Order, std::vector<Order>, decltype(&Order::buyComparator)> buyQueue{Order::buyComparator};
    std::priority_queue<Order, std::vector<Order>, decltype(&Order::sellComparator)> sellQueue{Order::sellComparator};
    
public:
    void addBuyOrder(const Order& order) {
        buyQueue.push(order);
    }
    
    void addSellOrder(const Order& order) {
        sellQueue.push(order);
    }
    
    void matchOrders() {
        while (!buyQueue.empty() && !sellQueue.empty() &&
               buyQueue.top().price >= sellQueue.top().price) {
            // 执行交易...
        }
    }
};
```



## **8. 比较总结**

| 数据结构 | 时间复杂度 | 空间复杂度 | 典型应用 | C++实现 |
|----------|------------|------------|----------|---------|
| **单调栈** | O(n) | O(n) | 下一个更大元素、直方图最大矩形 | `std::stack` |
| **优先队列** | 插入/删除O(log n) | O(n) | 任务调度、Dijkstra算法 | `std::priority_queue` |
| **堆** | 建堆O(n), 插入/删除O(log n) | O(n) | 堆排序、Top K问题 | `std::make_heap`系列 |
