# const
`const` 关键字用于声明常量，它指定了一个变量在初始化后不能被修改的特性。`const` 可以用于变量、成员函数和指针。

### 1. 常量变量（Const Variables）

常量变量一旦被初始化，就不能被修改。

```cpp
const int MAX_SIZE = 100; // 声明一个常量

int main() {
    // MAX_SIZE = 200; // 错误：常量不能被修改
    std::cout << "Max size: " << MAX_SIZE << std::endl;
    return 0;
}
```

### 2. 常量成员函数（Const Member Functions）

常量成员函数承诺不会修改对象的成员变量。在常量对象上调用常量成员函数是合法的，但在非常量对象上调用常量成员函数是不合法的。

```cpp
class MyClass {
public:
    int getValue() const { // 声明一个常量成员函数
        // some code
    }
};

int main() {
    const MyClass obj;
    int value = obj.getValue(); // 合法：在常量对象上调用常量成员函数
    return 0;
}
```

### 3. 指向常量的指针（Pointers to Constants）

指向常量的指针表示指针所指向的值是常量，**不能通过指针修改该值。

```cpp
int main() {
    const int* ptr; // 指向常量的指针
    int value = 5;
    ptr = &value;
    // *ptr = 10; // 错误：不能通过指针修改常量值
    return 0;
}
```

### 4. 常量指针（Constant Pointers）

常量指针表示指针本身是常量，**不能改变指针指向的地址。

```cpp
int main() {
    int value = 5;
    int* const ptr = &value; // 常量指针
    *ptr = 10; // 合法：可以通过常量指针修改指针指向的值
    // ptr = nullptr; // 错误：不能改变常量指针的指向
    return 0;
}
```
### 5.const 与 #define 的区别
**编译器处理方式不同**
define --> 在预处理阶段进行替换
const --> 在编译阶段确定其值

**类型检查**
define --> 无类型，不进行类型安全检查，可能会产生错误
const --> 有数据类型，编译时会检查

内存空间**
define --> 不分配内存，给出的是立即数，用了多少次就进行多少次替换，在内存中会有多个拷贝，消耗内存大
const --> 在静态存储区分配空间，程序运行中在内存中只有一次拷贝

在编译时，编译器通常不为const分配空间而是保存在符号表中，使得成为编译期间的常量，没有存储与读内存的操作，效率高。
宏替换只做替换，不做表达式计算。
# static
`static` 关键字用于声明**静态成员变量、静态成员函数和局部静态变量**，其作用取决于它所修饰的实体。

### 1. 静态成员变量（Static Member Variables）

静态成员变量是属于类的，而不是属于类的各个实例的。它的特点是所有类的实例共享同一份静态成员变量。静态成员变量可以通过类名直接访问，也可以通过对象访问。

```cpp
class MyClass {
public:
    static int count; // 声明静态成员变量
};

int MyClass::count = 0; // 初始化静态成员变量

int main() {
    MyClass obj1;
    MyClass obj2;
    
    obj1.count = 5; // 通过对象访问静态成员变量
    MyClass::count = 10; // 通过类名直接访问静态成员变量
    
    return 0;
}
```

### 2. 静态成员函数（Static Member Functions）

静态成员函数是属于类的函数，它不依赖于任何特定的对象。因此，它可以直接通过类名来调用，而不需要创建类的实例。

```cpp
class MyClass {
public:
    static void myStaticFunction() {
        // 静态成员函数的实现
    }
};

int main() {
    MyClass::myStaticFunction(); // 调用静态成员函数
    return 0;
}
```

### 3. 局部静态变量（Local Static Variables）

局部静态变量是在函数内部声明的静态变量，它具有静态生存期，即它在程序运行期间只初始化一次，并且在函数调用结束后仍然存在于内存中。

```cpp
void myFunction() {
    static int count = 0; // 声明局部静态变量
    count++;
    std::cout << "Count: " << count << std::endl;
}

int main() {
    myFunction();
    myFunction();
    myFunction();
    return 0;
}
```
### **1.作用范围**：

- `static` 关键字可以用于修饰变量、函数和类，它具有不同的作用效果。
- `const` 关键字用于声明常量，可以修饰变量、成员函数和指针。

### **2.作用时间**：

- `static` 关键字表示静态的特性，它的作用是在编译时期确定，程序运行过程中不会改变。
- `const` 关键字表示常量的特性，它的值在初始化后不能被修改。

### **3.内存分配**：

- `static` 修饰的静态变量在程序的静态存储区分配内存，它的生命周期贯穿整个程序的执行过程。
- `const` 修饰的常量可以是静态变量、全局变量、局部变量或者类的成员变量，其内存分配取决于其声明的位置和作用域。

### **4.用途**：

- `static` 用于实现静态成员变量、静态成员函数、局部静态变量等，通常用于共享数据和实现单例模式。
- `const` 用于声明常量，以及在成员函数中表明函数不会修改对象的状态，从而提高代码的安全性和可读性。



# volatile

对于 define 来说，宏定义实际上是在预编译阶段进⾏处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定 义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期 的效果。因为 define 宏定义仅仅是展开，因此运⾏时系统并不为宏定义分配内存，但是从汇编 的⻆度来讲， define 却以⽴即数的⽅式保留了多份数据的拷⻉。 对于 const 来说，const 是在编译期间进⾏处理的，const 有类型，也有类型检查，程序运⾏时系统会为 const 常 分配内存，⽽且从汇编的⻆度讲，const 常在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的 拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常分配内存，⽽是直接将 const 常添 加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。



static 作⽤：控制变的存储⽅式和可⻅性。 作⽤⼀：修饰局部变：⼀般情况下，对于局部变在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块 执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变便会存放在静态数据区，其⽣命周期会⼀直延续 到整个程序执⾏结束。但是要注意的是，虽然⽤ static 对局部变进⾏修饰之后，其⽣命周期以及存储空间发⽣了 变化，但其作⽤域并没有改变，作⽤域还是限制在其语句块。 作⽤⼆：修饰全部变：对于⼀个全局变，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被 访问(添加 extern进⾏声明即可)。⽤ static 对全局变进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成 了本⽂件可⻅。 作⽤三：修饰函数：⽤ static 修饰函数，情况和修饰全局变类似，也是改变了函数的作⽤域。 作⽤四：修饰类：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何 特定对象；如果对类中的某个变进⾏ static 修饰，则表示该变以及所有的对象所有，存储空间中只存在⼀个副 本，可以通过；类和对象去调⽤。 （补充：静态⾮常数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。） 作⽤五：类成员/类函数声明 static 函数体内 static 变的作⽤范围为该函数体，不同于 auto 变，该变的内存只被分配⼀次，因此其值在下 次调⽤时仍维持上次的值； 在模块内的 static 全局变可以被模块内所⽤函数访问，但不能被模块外其它函数访问； 在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内； 在类中的 static 成员变属于整个类所拥有，对类的所有对象只有⼀份拷⻉； 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变 。 static 类对象必须要在类外进⾏初始化，static 修饰的变先于对象存在，所以 static 修饰的变要在类外初 始化； 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本 对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰 的类成员； static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意 义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指 针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function。 const 关键字：含义及实现机制 const 修饰基本类型数据类型：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后， 其结果是⼀样的。在使⽤这些常的时候，只要不改变这些常的值即可。 const 修饰指针变和引⽤变：如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变，即指 针指向为常；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常。 const 应⽤到函数中：作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变初始化 const 常，则在函数体 中，按照 const 所修饰的部分进⾏常化，保护了原对象的属性。 [注意]：参数 const 通常⽤于参数为指针或引⽤ 的情况; 作为函数返回值的 const 修饰符：声明了返回值后，const 按照"修饰原则"进⾏修饰，起到相应的保护作 ⽤。 const 在类中的⽤法：const 成员变，只在某个对象⽣命周期内是常，⽽对于整个类⽽⾔是可以改变的。因为 类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员， 因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构 造函数的初始化列表中进⾏。const 成员函数：const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注 意，const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含 有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。 const 修饰类对象，定义常对象：常对象只能调⽤常函数，别的成员函数都不能调⽤。 补充：const 成员函数中如果实在想修改某个变，可以使⽤ mutable 进⾏修饰。成员变中如果想建⽴在整个类 中都恒定的常，应该⽤类中的枚举常来实现或者 static const。 C ++ 中的 const类成员函数（⽤法和意义） 常对象可以调⽤类中的 const 成员函数，但不能调⽤⾮ const 成员函数； （原因：对象调⽤成员函数时，在形 参列表的最前⾯加⼀个形参 this，但这是隐式的。this 指针是默认指向调⽤函数的当前对象的，所以，很⾃然， this 是⼀个常指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即⼩括号） 后加了 const 关键字（void print() const;），此成员函数为常成员函数，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值。 ⾮常对象可以调⽤类中的 const 成员函数，也可以调⽤⾮ const 成员函数。


---

# inline
编译器工作时，以 .c 文件为单位逐个编译 .o 文件，每个 .c 文件的编译是独立的，如果 当前 .c 文件中要用到外部函数，那么就在编译时预留一个符号。等到所有 .o 文件生成后，链接时才给这些符号指定地址（链接脚本决定地址），所以这个 . c 文件编译时只会看到外部函数的声明而无法知道它的函数体。而内联函数声明时，加关键字 inline 修饰。调用到它的地方直接将汇编代码展开，而不需要通过符号（函数名）地址跳转。
## 内联函数

**在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。

为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。

栈空间就是指放置程序代码的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

## 代码用例

```c
#include <stdio.h>  
 
//函数定义为inline即:内联函数  
inline char* dbtest(int a) 
{  
	return (i % 2 > 0) ? "奇" : "偶";  
}   
  
int main()  
{  
	int i = 0;  
	for (i=1; i < 100; i++) 
	{  
		printf("i:%d    奇偶性:%s /n", i, dbtest(i));      
	}  
}
```

**其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2>0)?“奇”:“偶”，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。**

## 内联函数编程风格

##### 1、关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。

如下风格的函数Foo 不能成为内联函数：

```c
inline void Foo(int x, int y); // inline 仅与函数声明放在一起
void Foo(int x, int y)
{
}
```

而如下风格的函数Foo 则成为内联函数：

```c
void Foo(int x, int y);
inline void Foo(int x, int y) // inline 与函数定义体放在一起
{
}
```

所以说，inline 是一种 **“用于实现的关键字**” ，**而不是一种“用于声明的关键字”**。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：**声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联**。

##### 2、inline的使用是有所限制的

inline只适合**函数体内代码简单**的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是**直接递归函数**(自己内部还调用自己的函数)。

##### 3、慎用内联

内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？

**内联是以代码膨胀（复制）为代价**，仅仅省去了函数调用的开销，从而提高函数的执行效率。**如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少**。另一方面，**每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。**

以下情况不宜使用内联：

（1）如果函数体内的**代码比较长**，使用内联将导致内存消耗代价较高。

（2）如果函数体内**出现循环**，那么执行函数体内代码的时间要比函数调用的开销大。

一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。

##### 4、将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦

而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为。

# extern
利用关键字extern，可以在一个文件中引用另一个文件中定义的变量或者函数，下面就结合具体的实例，分类说明一下。

## 一、引用同一个文件中的变量

```c
#include<stdio.h>

int func();

int main()
{
    func(); //1
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}

```

如果按照这个顺序，变量 num在main函数的后边进行声明和初始化的话，那么在main函数中是不能直接引用num这个变量的，因为当编译器编译到这一句话的时候，找不到num这个变量的声明，但是在func函数中是可以正常使用，因为func对num的调用是发生在num的声明和初始化之后。

如果我不想改变num的声明的位置，但是想在main函数中直接使用num这个变量，怎么办呢？可以使用extern这个关键字。像下面这一段代码，利用extern关键字先声明一下num变量，告诉编译器num这个变量是存在的，但是不是在这之前声明的，你到别的地方找找吧，果然，这样就可以顺利通过编译啦。但是你要是想欺骗编译器也是不行的，比如你声明了extern int num；但是在后面却没有真正的给出num变量的声明，那么编译器去别的地方找了，但是没找到还是不行的。

下面的程序就是利用extern关键字，使用在后边定义的变量。

```c
#include<stdio.h>

int func();

int main()
{
    func(); //1
    extern int num;
    printf("%d",num); //2
    return 0;
}

int num = 3;

int func()
{
    printf("%d\n",num);
}

```

## 二、引用另一个文件中的变量

如果extern这个关键字就这点功能，那么这个关键字就显得多余了，因为上边的程序可以通过将num变量在main函数的上边声明，使得在main函数中也可以使用。  
extern这个关键字的真正的作用是引用不在同一个文件中的变量或者函数。  
**main.c**

```c
#include<stdio.h>

int main()
{
    extern int num;
    printf("%d",num);
    return 0;
}
```

**b.c**

```c
#include<stdio.h>

int num = 5;

void func()
{
    printf("fun in a.c");
}

```

例如，这里b.c中定义了一个变量num，如果main.c中想要引用这个变量，那么可以使用extern这个关键字，注意这里能成功引用的原因是，num这个关键字在b.c中是一个全局变量，也就是说只有当一个变量是一个全局变量时，extern变量才会起作用。

另外，extern关键字只需要指明类型和变量名就行了，不能再重新赋值，初始化需要在原文件所在处进行，如果不进行初始化的话，全局变量会被编译器自动初始化为0。

像这种写法是不行的。  
`extern int num=4;`  
但是在声明之后就可以使用变量名进行修改了。

```c
#include<stdio.h>

int main()
{
    extern int num;
    num=1;
    printf("%d",num);
    return 0;
}

```

使用include将另一个文件全部包含进去可以引用另一个文件中的变量，但是这样做的结果就是，被包含的文件中的所有的变量和方法都可以被这个文件使用，这样就变得不安全，如果只是希望一个文件使用另一个文件中的某个变量还是使用extern关键字更好。

## 引用另一个文件中的函数

extern除了引用另一个文件中的变量外，还可以引用另一个文件中的函数，引用方法和引用变量相似。  
mian.c

```c
#include<stdio.h>

int main()
{
    extern void func();
    func();
    return 0;
}
```

b.c

```c
#include<stdio.h>

const int num=5;
void func()
{
    printf("fun in a.c");
}
```

这里main函数中引用了b.c中的函数func。因为所有的函数都是全局的，所以对函数的extern用法和对全局变量的修饰基本相同，需要注意的就是，需要指明返回值的类型和参数。
## 区别
| 特性         | `inline`                               | `extern`                  |
| ---------- | -------------------------------------- | ------------------------- |
| **用途**     | 建议编译器将函数调用替换为函数主体代码，以优化性能。             | 声明变量或函数在其他文件中定义，用于跨文件链接。  |
| **作用对象**   | 函数。                                    | 变量或函数。                    |
| **使用位置**   | 函数定义。                                  | 变量或函数声明。                  |
| **对链接的影响** | 编译器可能将多个 `inline` 函数的定义合并为一个，避免重复符号错误。 | 告诉编译器变量或函数在其他地方定义，避免链接错误。 |
| **性能影响**   | 可能提高性能，减少函数调用开销。                       | 无直接影响，主要用于链接阶段。           |

---

# this


# explicit

# ：：

# decltype
# namespace
https://blog.csdn.net/qq_40416052/article/details/82528676?fromshare=blogdetail&sharetype=blogdetail&sharerId=82528676&sharerefer=PC&sharesource=cos03&sharefrom=from_link