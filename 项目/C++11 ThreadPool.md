[【C++ 并发 线程池】轻松掌握C++线程池：从底层原理到高级应用（一）-阿里云开发者社区](https://developer.aliyun.com/article/1464325)
[C/C++手撕线程池（线程池的封装和实现）_c++线程池-CSDN博客](https://blog.csdn.net/ACMer_L/article/details/107578636)

项目来源：[基于C++11实现线程池 - 知乎](https://zhuanlan.zhihu.com/p/367309864)

[现代C++之万能引用、完美转发、引用折叠 - 知乎](https://zhuanlan.zhihu.com/p/99524127)

---
# 线程池简介

线程池的基本概念是，在应用程序启动时创建一定数量的线程，并将它们保存在线程池中。当需要执行任务时，从线程池中获取一个空闲的线程，将任务分配给该线程执行。当任务执行完毕后，线程将返回到线程池，可以被其他任务复用。

线程池是一种**并发编程技术**，它能有效地管理并发的线程、减少资源占用和提高程序的性能
### 线程池结构

在计算机体系结构中有许多池式结构：[[TC malloc 内存池]]内存池、数据库连接池、请求池、消息队列、对象池等等。池式结构解决的主要问题为**缓冲问题**，起到的是缓冲区的作用。


如图所示，我们将整个框架以及任务添加接口定义为线程池的“**池**”，那么在这个池子中重要的就是**工作队列**、**任务队列**、以及决定工作队列中的`thread`到底应该工作还是休息的**回调函数**。

![[assets/C++11 ThreadPool/file-20250616101823499.png]]

### 线程池原理
线程池一般是要复用线程，所以如果是取一个task分配给某一个thread，执行完之后再重新分配，在语言层面这是基本不能实现的：C++的thread都是执行一个固定的task函数，执行完之后线程也就结束了。所以该如何实现task和thread的分配呢？

**让每一个thread创建后，就去执行调度函数：循环获取task，然后执行。**

这个循环该什么时候停止呢？

很简单，**当线程池停止使用时**，循环停止。

这样一来，就保证了thread函数的唯一性，而且复用线程执行task。那我们的线程池主要组成有任务队列和线程池组成。

线程池与任务队列之间的匹配操作，是典型的[[../900拓展知识/生产者消费者模型]]，本模型使用了两个工具：一个mutex + 一个条件变量。mutex就是锁，保证任务的添加和移除（获取）的互斥性；一个条件变量保证多个线程获取task的同步性：当任务队列为空时，线程应该等待（阻塞）。
#### **任务队列（TaskQueue）**
我们会理所当然地希望任务以发送它相同的顺序来逐个执行，因此队列是最适合的数据结构。

当两个甚至多个线程试图同时执行查询工作时，这会引起难以估计的灾难。因而我们需要对C++的`std::queue`进行包装，实现一个**线程安全**的_SafeQueue_。

#### **线程池（Thread Pool）
##### 提交函数

##### 内置工作线程类

### 线程池解决的问题与应用

#### 线程竞争问题解决

过多的线程可能导致线程竞争，影响系统性能。线程池通过维护一个可控制的并发数量，有助于减轻线程之间的竞争。例如，当CPU密集型任务和I/O密集型任务共存时，可以通过调整线程池资源，实现更高效的负载平衡。
#### 线程创建开销解决

多线程环境下，每当需要执行一个任务时，创建与销毁线程都需要额外的系统资源。线程池通过预先创建一定数量的线程，可以减少这种资源消耗。

#### 线程池应用：日志存储
在服务器保存日志至磁盘上时，性能往往压在磁盘读写上，而引入线程池利用**异步解耦**可以解决磁盘读写性能问题。
线程池的主要作用：异步解耦

### 线程池放缩方案：

- 当空闲线程数量大于80%时，减少线程池中线程个数将空闲线程数量控制在50%。
- 当空闲线程数量小于40%时，增加线程池中线程个数并将空闲线程数量控制在50%。

此功能是不是画蛇添足有待考证，但是若当我们的工作线程数量不稳定时，频繁调整线程池的线程数量（频繁创建及释放线程）也将导致性能的下降，这种做法理所当然地被我认为是一种本末倒置的做法，而对于线程池中线程的数量，在我做性能测试时考虑到CPU是四核的，就只在线程池中创建了4个线程。关于线程池中线程合理的数量，大家可自行网上查找相关研究，笔者在此给出大部分的结论：

**最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
# C++11语法
**可变模版参数**

**尾返回类型推导**

C++11关键字`decltype`
std::future

lambda表达式

`std::forward()`又被称作**完美转发**

**万能引用**（左值引用与右值引用）

#### std::thread

`std::thread`是C++ 11提供的原生线程库，

### 遇到的问题

隐藏的特殊字符（零宽空格）



# 面试常见问题


