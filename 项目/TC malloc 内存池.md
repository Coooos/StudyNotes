---
date: 
tags:
  - study
---

项目来源：[【项目】九万字手把手教你写高并发内存池（化简版tcmalloc）-CSDN博客](https://blog.csdn.net/m0_62782700/article/details/135443352)

## NEW和Malloc的区别

`new` 是 C++ 的操作符，用于对象分配，安全且自动初始化；`malloc` 是 C 的函数，仅分配内存，需手动管理类型和初始化。new的底层是用malloc实现的。new和delete中封装了operator new和operator delete。 operator new中又调用了malloc来帮助new来开空间，封装malloc复合C++中new失败了抛异常的机制。 operator delete中也是通过宏定义后的free来释放空间。所以说C/C++中申请和释放内存块最终还是通过malloc和free来实现的。


![[assets/Pasted image 20250427152221.png]]

## 为什么需要内存池

内存池是为了提高程序运行效率和减少内存碎片而设计的一种技术。以下是使用内存池的主要原因：

1. 减少内存分配和释放的开销：传统的动态内存分配（如malloc、free）会涉及到操作系统的系统调用，这样会产生较大的开销。而使用内存池可以预先分配一块连续的内存空间，并在需要时直接从中取出或回收，避免频繁进行系统调用，从而提高了程序性能。
    
2. 减少内存碎片：频繁地进行动态内存分配和释放容易导致堆中产生碎片化的空间。而使用内存池可以固定大小的块来管理内存，避免了不同大小的对象交错排布在堆上导致的碎片问题。
    
3. 提高缓存命中率：将对象预先分配到连续的块中，可以利用局部性原理提高缓存命中率。相邻对象在物理上也相邻，利于CPU缓存预取等优化。

### 内存碎片问题

内存碎片是指已分配的内存空间中存在的一些零散、不连续的小块未被使用的内存。这会导致内存利用率下降，可能影响程序的性能和稳定性。造成堆利用率很低的一个主要原因就是内存碎片化。如果有未使用的存储器，但是这块存储器不能用来满足分配的请求，这时候就会产生内存碎片化问题。

内存碎片主要分为两种类型：外部碎片和内部碎片。

1. 外部碎片：即由于已分配内存块的释放而造成的未被充分利用的空闲内存块。这些空闲块虽然总大小足够，但由于彼此之间存在占用的块，无法组合成足够大的连续空闲区域。
    
2. 内部碎片：即已分配给进程或应用程序的内存中，实际使用但没有被完全填满的部分。例如，某个进程申请了100个字节的内存，但只实际使用了80个字节，那么剩下的20个字节就构成了一个内部碎片。


![[assets/Pasted image 20250427093731.png]]

## 高并发内存池基本框架
一个进程中有几个线程，就会有几个tc，也就是每一个线程都会有其对应的tc，可以认为tc就是一个类的对象，内部包含一些数据结构，并保存了一些空间。

如上图所示，假设有三个线程，分别为t1、t2、t3。每个线程去动态申请内存时不需要加锁，因为每个线程独享一个tc，如果tc中有空闲空间，线程在申请的时候只会去自己的tc中申请。单次向tc申请的最大上限为256KB。

如果单次申请的空间是小于256KB的，线程就在自己的tc中申请，且大部分情况下申请空间是不会大于256KB的，毕竟256KB都已经26万多字节了，这样就可以解决大部分情况下的锁竞争问题，因为自己向自己的tc申请空间不需要加锁。

如果单次申请的空间大于了256KB，tc就会用其他方式去申请空间，
### threadCache
每来一个size都要有一套规则去计算对应的桶在哪里，比如要20B就找对应24B的桶，看24B对应的自由链表下面有没有挂空闲的空间，如果有了就拿一块给对应线程，如果没有就向下一层的central cache申请。
![[assets/Pasted image 20250427153931.png]]
### 申请与释放空间流程

![[assets/Pasted image 20250427094026.png]]![[assets/Pasted image 20250427094043.png]]










### 线程局部存储（TLS）
一个进程可能有多个线程，多个线程几乎是共享整个进程的虚拟地址空间，每个线程有独立的栈、寄存器等独有的空间或数据，这里想要每个线程都有一个ThreadCache，那如何让线程与线程之间的ThreadCache不会相互影响呢？如何控制某个ThreadCache一定属于某个线程呢？一个进程要创建多少个ThreadCache呢？
进程的全局变量是每个线程共享的，那有没有一种全局变量能让某个线程自己独有但是其他线程看不见呢？答案是有的，就是TLS。线程局部存储（TLS），是一种变量的存储方法，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性，避免了一些加锁操作，控制成本更低。
```
// TLS的全局对象的指针,这样每个线程都能有一个独立的全局对象
static _declspec(thread) ThreadCache* pTLSThreadCache = nullptr;
```


**非静态成员函数需要通过类的实例来调用，而静态成员函数可以通过类名或类指针来调用，不需要实例。**










### 关于锁
tc中没有锁，因为每个线程独有一个ThreadCache。

cc中有桶锁，为了尽量保证效率和安全，采用桶锁，以供多线程并发向单个桶申请空间块时安全又高效。

pc中有整体锁，因为多线程并发申请span时会导致span的分裂和合并，只能保证安全。但经过三层的缓存，效率上并不会有太大影响。

定长内存池中需要一个锁，为了防止多线程并发创建ThreadCache时会导致某个线程获取到一个空指针，从而使得定位new时程序崩溃。

## 遇到的问题
（1）运行速度问题：
调用类成员静态函数：FreeList::ObjNext（） 为什么比直接调用全局静态函数ObjNext（）慢很多。


## 学到的东西
1代码调试
2 性能探查器



### **1. 哈希表（Hash Table）**
哈希表是一种基于哈希函数实现的高效数据结构，用于存储键值对（Key-Value Pair）。它的主要目标是通过哈希函数将键映射到一个存储位置，从而实现快速的插入、查找和删除操作。

#### **特点**
- **高效性**：哈希表的平均时间复杂度为 \(O(1)\)，在理想情况下，插入、查找和删除操作都非常快。
- **哈希函数**：哈希表的核心是哈希函数，它将键映射到一个整数（通常是索引），用于确定键值对在存储结构中的位置。
- **冲突解决**：由于哈希函数的输出范围有限，不同的键可能会映射到同一个位置，这称为冲突（Collision）。哈希表需要通过某种策略（如链地址法、开放定址法等）来解决冲突。

#### **结构**
哈希表通常由以下部分组成：
- **哈希函数**：将键映射到一个整数索引。
- **存储结构**：用于存储键值对，通常是数组或链表。
- **冲突解决机制**：用于处理哈希冲突。

### **2. 哈希桶（Hash Bucket）**
哈希桶是哈希表内部的一个存储单元，用于存储键值对。哈希表通过哈希函数将键映射到一个哈希桶中，每个哈希桶可以存储一个或多个键值对。

#### **特点**
- **存储单元**：哈希桶是哈希表的底层存储单元，通常是一个数组或链表。
- **索引映射**：哈希函数的输出决定了键值对存储到哪个哈希桶中。
- **冲突处理**：当多个键映射到同一个哈希桶时，需要通过某种方式（如链表、开放定址法等）来存储这些键值对。

#### **结构**
哈希桶的结构取决于哈希表的实现方式：
- **链地址法（Separate Chaining）**：每个哈希桶是一个链表，存储所有映射到该桶的键值对。
- **开放定址法（Open Addressing）**：所有键值对存储在同一个数组中，冲突通过某种策略（如线性探测、二次探测等）解决。

### **3. 哈希表与哈希桶的区别**
| 特性 | 哈希表（Hash Table） | 哈希桶（Hash Bucket） |
|------|----------------------|-----------------------|
| **层次** | 高层数据结构，用于存储键值对 | 低层存储单元，是哈希表的组成部分 |
| **功能** | 提供高效的插入、查找和删除操作 | 存储键值对，处理冲突 |
| **结构** | 包括哈希函数、存储结构和冲突解决机制 | 通常是数组或链表中的一个单元 |
| **哈希函数** | 使用哈希函数将键映射到哈希桶 | 哈希桶是哈希函数输出的存储位置 |
| **冲突处理** | 通过某种策略（如链地址法、开放定址法）解决冲突 | 具体存储冲突的键值对 |
| **示例** | `std::unordered_map`（C++ STL） | `std::unordered_map` 中的每个存储单元 |

### **4. 示例**
假设我们有一个简单的哈希表，使用链地址法解决冲突：

#### **哈希表的实现**
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <functional>

class HashTable {
public:
    HashTable(size_t size = 10) : table(size) {}

    void insert(int key, const std::string& value) {
        size_t index = hash_function(key);
        table[index].push_back(std::make_pair(key, value));
    }

    std::string find(int key) {
        size_t index = hash_function(key);
        for (const auto& pair : table[index]) {
            if (pair.first == key) {
                return pair.second;
            }
        }
        return "Not found";
    }

private:
    std::vector<std::list<std::pair<int, std::string>>> table;

    size_t hash_function(int key) {
        return std::hash<int>()(key) % table.size();
    }
};

int main() {
    HashTable ht;
    ht.insert(1, "one");
    ht.insert(2, "two");
    ht.insert(11, "eleven"); // 哈希冲突，1 和 11 映射到同一个桶

    std::cout << "Key 1: " << ht.find(1) << std::endl;
    std::cout << "Key 11: " << ht.find(11) << std::endl;

    return 0;
}
```

#### **代码解析**
- **哈希表**：整个数据结构，包括哈希函数、存储结构和冲突解决机制。
- **哈希桶**：`table` 中的每个 `std::list`，用于存储映射到该桶的键值对。

### **总结**
- **哈希表**是一个高层数据结构，用于实现高效的键值对存储和查找。
- **哈希桶**是哈希表的底层存储单元，用于存储键值对并处理冲突。
- 哈希表通过哈希函数将键映射到哈希桶，哈希桶负责存储键值对并解决冲突。



# 面试常见问题